# Lab 6-2 Analysis
### Virus Total Search
**Name**: Trojan:Win32/Generic.be125c32
**Compiler**: `Compiler: EP:Microsoft Visual C/C++(6.0 (1720-9782))[EXE32]`

### First subroutine in main action
After first lab I found that this program will extract main function to subroutine (like in lab 6-1)
```asm
.text:00401239                 call    sub_402001
.text:0040123E                 call    sub_401F48
.text:00401243                 call    sub_401CC2
.text:00401248                 mov     eax, dword_409A18
.text:0040124D                 mov     dword_409A1C, eax
.text:00401252                 push    eax
.text:00401253                 push    dword_409A10
.text:00401259                 push    dword_409A0C
.text:0040125F                 call    MAIN_ENTRY
.text:00401264                 add     esp, 0Ch
.text:00401267                 mov     [ebp+var_1C], eax
.text:0040126A                 push    eax             ; uExitCode
.text:0040126B                 call    sub_401CEF
```

That's why we have to check function `sub.0040125F` for question answer:
```asm
.text:00401130 MAIN_ENTRY      proc near               ; CODE XREF: start+AF↓p
.text:00401130
.text:00401130 var_8           = byte ptr -8
.text:00401130 var_4           = dword ptr -4
.text:00401130
.text:00401130                 push    ebp
.text:00401131                 mov     ebp, esp
.text:00401133                 sub     esp, 8
.text:00401136                 call    conn_check
.text:0040113B                 mov     [ebp+var_4], eax
.text:0040113E                 cmp     [ebp+var_4], 0
.text:00401142                 jnz     short loc_401148
.text:00401144                 xor     eax, eax
.text:00401146                 jmp     short loc_40117B
.text:00401148 ; ---------------------------------------------------------------------------
.text:00401148
.text:00401148 loc_401148:                             ; CODE XREF: MAIN_ENTRY+12↑j
.text:00401148                 call    malware_action
.text:0040114D                 mov     [ebp+var_8], al
.text:00401150                 movsx   eax, [ebp+var_8]
.text:00401154                 test    eax, eax
.text:00401156                 jnz     short loc_40115C
.text:00401158                 xor     eax, eax
.text:0040115A                 jmp     short loc_40117B
.text:0040115C ; ---------------------------------------------------------------------------
.text:0040115C
.text:0040115C loc_40115C:                             ; CODE XREF: MAIN_ENTRY+26↑j
.text:0040115C                 movsx   ecx, [ebp+var_8]
.text:00401160                 push    ecx
.text:00401161                 push    offset aSuccessParsedC ; "Success: Parsed command is %c\n"
.text:00401166                 call    sub_40117F
.text:0040116B                 add     esp, 8
.text:0040116E                 push    0EA60h          ; dwMilliseconds
.text:00401173                 call    ds:Sleep
.text:00401179                 xor     eax, eax
.text:0040117B
.text:0040117B loc_40117B:                             ; CODE XREF: MAIN_ENTRY+16↑j
.text:0040117B                                         ; MAIN_ENTRY+2A↑j
.text:0040117B                 mov     esp, ebp
.text:0040117D                 pop     ebp
.text:0040117E                 retn
.text:0040117E MAIN_ENTRY      endp
```

Herer we can see 4 subroutines:
* `sub.00401136` - will do the connection check like in lab 6-1
* `sub.00401148` - will perform some internet activity
* `sub.00401166` - we will check this function later
* Sleep() in the end of the function

According first subroutine:
```asm
.text:00401000 var_4           = dword ptr -4
.text:00401000
.text:00401000                 push    ebp
.text:00401001                 mov     ebp, esp
.text:00401003                 push    ecx
.text:00401004                 push    0               ; dwReserved
.text:00401006                 push    0               ; lpdwFlags
.text:00401008                 call    ds:InternetGetConnectedState
.text:0040100E                 mov     [ebp+var_4], eax
.text:00401011                 cmp     [ebp+var_4], 0
.text:00401015                 jz      short loc_40102B
.text:00401017                 push    offset aSuccessInterne ; "Success: Internet Connection\n"
.text:0040101C                 call    sub_40117F
.text:00401021                 add     esp, 4
.text:00401024                 mov     eax, 1
.text:00401029                 jmp     short loc_40103A
.text:0040102B ; ---------------------------------------------------------------------------
.text:0040102B
.text:0040102B loc_40102B:                             ; CODE XREF: conn_check+15↑j
.text:0040102B                 push    offset aError11NoInter ; "Error 1.1: No Internet\n"
.text:00401030                 call    sub_40117F
.text:00401035                 add     esp, 4
.text:00401038                 xor     eax, eax
.text:0040103A
.text:0040103A loc_40103A:                             ; CODE XREF: conn_check+29↑j
.text:0040103A                 mov     esp, ebp
.text:0040103C                 pop     ebp
.text:0040103D                 retn
.text:0040103D conn_check      endp
```
It's lab-6-1 function for connection check
### What is sub on 0x40117F?
It's a `printf()` function as in lab 6-1

### Second subroutine in main action
Second function is main activity of the malware. After the connection check it will call this function. It will try to emulate IE http call to external resource:
```asm
.text:00401049                 push    0               ; dwFlags
.text:0040104B                 push    0               ; lpszProxyBypass
.text:0040104D                 push    0               ; lpszProxy
.text:0040104F                 push    0               ; dwAccessType
.text:00401051                 push    offset szAgent  ; "Internet Explorer 7.5/pma"
.text:00401056                 call    ds:InternetOpenA
.text:0040105C                 mov     [ebp+hInternet], eax
.text:0040105F                 push    0               ; dwContext
.text:00401061                 push    0               ; dwFlags
.text:00401063                 push    0               ; dwHeadersLength
.text:00401065                 push    0               ; lpszHeaders
.text:00401067                 push    offset szUrl    ; "http://www.practicalmalwareanalysis.com"...
.text:0040106C                 mov     eax, [ebp+hInternet]
.text:0040106F                 push    eax             ; hInternet
.text:00401070                 call    ds:InternetOpenUrlA
```

It will simply get the command from remote server `http://www.practicalmalwareanalysis.com/cc.htm`
### Code construct in (3)
Code constructions:
```asm
.text:00401070                 call    ds:InternetOpenUrlA
.text:00401076                 mov     [ebp+hFile], eax
.text:00401079                 cmp     [ebp+hFile], 0
.text:0040107D                 jnz     short loc_40109D
.text:0040107F                 push    offset aError21FailToO ; "Error 2.1: Fail to OpenUrl\n"
.text:00401084                 call    sub_40117F
.text:00401089                 add     esp, 4
.text:0040108C                 mov     ecx, [ebp+hInternet]
.text:0040108F                 push    ecx             ; hInternet
.text:00401090                 call    ds:InternetCloseHandle
.text:00401096                 xor     al, al
.text:00401098                 jmp     loc_40112C
```
This is "if statement" that handles internet connection errors. It will printf error "Fail to OpenURl"

```asm
push    edx             ; lpdwNumberOfBytesRead
.text:004010A1                 push    200h            ; dwNumberOfBytesToRead
.text:004010A6                 lea     eax, [ebp+Buffer]
.text:004010AC                 push    eax             ; lpBuffer
.text:004010AD                 mov     ecx, [ebp+hFile]
.text:004010B0                 push    ecx             ; hFile
.text:004010B1                 call    ds:InternetReadFile
.text:004010B7                 mov     [ebp+var_4], eax
.text:004010BA                 cmp     [ebp+var_4], 0
.text:004010BE                 jnz     short loc_4010E5
```
In this section the programm will handle ReadFile error after InternetReadFile() call.

In next section we can see typical swtich block:
```asm
loc_4010E5:                             ; CODE XREF: malware_action+7E↑j
.text:004010E5                 movsx   ecx, [ebp+Buffer]
.text:004010EC                 cmp     ecx, 3Ch ; '<'
.text:004010EF                 jnz     short loc_40111D
.text:004010F1                 movsx   edx, [ebp+var_20F]
.text:004010F8                 cmp     edx, 21h ; '!'
.text:004010FB                 jnz     short loc_40111D
.text:004010FD                 movsx   eax, [ebp+var_20E]
.text:00401104                 cmp     eax, 2Dh ; '-'
.text:00401107                 jnz     short loc_40111D
.text:00401109                 movsx   ecx, [ebp+var_20D]
.text:00401110                 cmp     ecx, 2Dh ; '-'
.text:00401113                 jnz     short loc_40111D
.text:00401115                 mov     al, [ebp+var_20C]
.text:0040111B                 jmp     short loc_40112C
.text:0040111D ; ---------------------------------------------------------------------------
.text:0040111D
.text:0040111D loc_40111D:                             ; CODE XREF: malware_action+AF↑j
.text:0040111D                                         ; malware_action+BB↑j ...
.text:0040111D                 push    offset aError23FailToG ; "Error 2.3: Fail to get command\n"
.text:00401122                 call    sub_40117F
.text:00401127                 add     esp, 4
.text:0040112A                 xor     al, al
.text:0040112C
.text:0040112C loc_40112C:                             ; CODE XREF: malware_action+58↑j
.text:0040112C                                         ; malware_action+A3↑j ...
.text:0040112C                 mov     esp, ebp
.text:0040112E                 pop     ebp
.text:0040112F                 retn
```

It will try to parse the command and will wait for `<`, `!`, `-` characters, otherwise it will return an error.

After the fuction execution it will perform one more if statement in oder to show if command is valid:
```asm
loc_401148:                             ; CODE XREF: MAIN_ENTRY+12↑j
.text:00401148                 call    malware_action
.text:0040114D                 mov     [ebp+var_8], al
.text:00401150                 movsx   eax, [ebp+var_8]
.text:00401154                 test    eax, eax
.text:00401156                 jnz     short loc_40115C
.text:00401158                 xor     eax, eax
.text:0040115A                 jmp     short loc_40117B
.text:0040115C ; ---------------------------------------------------------------------------
.text:0040115C
.text:0040115C loc_40115C:                             ; CODE XREF: MAIN_ENTRY+26↑j
.text:0040115C                 movsx   ecx, [ebp+var_8]
.text:00401160                 push    ecx
.text:00401161                 push    offset aSuccessParsedC ; "Success: Parsed command is %c\n"
.text:00401166                 call    sub_40117F
.text:0040116B                 add     esp, 8
.text:0040116E                 push    0EA60h          ; dwMilliseconds
.text:00401173                 call    ds:Sleep
.text:00401179                 xor     eax, eax
.text:0040117B
.text:0040117B loc_40117B:                             ; CODE XREF: MAIN_ENTRY+16↑j
.text:0040117B                                         ; MAIN_ENTRY+2A↑j
.text:0040117B                 mov     esp, ebp
.text:0040117D                 pop     ebp
.text:0040117E                 retn
```
If command is valid, malware will printf message `Success: Parsed command is %c\n % command` and then will call Sleep() for 60 seconds
### Network-based indicators
It will perform HTTP request to `http://www.practicalmalwareanalysis.com/cc.htm` in order to get the command. In addition it will set user agent to `Internet Explorer 7.5/pma`
### Purpose of this malware?
Simple "educational" trojan:
1. Check internet
2. Perform HTTP request to remote server
3. Parse the command from remote server
4. Print parsed command
5. Sleep 60 seconds

**Score** 10/10
