# f0rizen's find a real key crackme
This is very nice crackme. Difficulty level is between level 2 and level 3 (https://crackmes.one/crackme/629e1e5833c5d4251e72375f)

### Basic checks
**Just try it**

``` 
%crackme test
Wrong flag
```

**Look for strings**
```
#strings crackme
...
Usage: ./crackme FLAG
Wrong flag
sup3r_s3cr3t_k3y_1337
You found a flag! %s
...
```
The key looks like a flag, but I think it's fake. Let's check it:
```
crackme sup3r_s3cr3t_k3y_1337
>>Wrong flag 
```

### Binary Analysis
Header analysis with `die`
```
Binary data: 
Operation system: Gentoo Linux(ABI: 3.2.0)[AMD64, 64-bit, DYN]                  
Compiler: GCC(10.3.0)   
Language: C/C++
```
No obfuscation detected.

The binary file contails relatively small amount of functions:
```asm
[0x00001080]> afl
0x00001000    3 23           sym._init
0x00001030    1 6            sym.imp.puts
0x00001040    1 6            sym.imp.strlen
0x00001050    1 6            sym.imp.__stack_chk_fail
0x00001060    1 6            sym.imp.printf
0x00001070    1 6            sub.__cxa_finalize_248_70
0x00001080    1 43           entry0
0x000010b0    3 33           sub._ITM_deregisterTMCloneTable_216_b0
0x00001120    4 49           entry2.fini
0x00001160    5 5    -> 56   entry1.init
0x00001165   16 518          main
0x00001370    4 93           sym.__libc_csu_init
0x000013d0    1 1            sym.__libc_csu_fini
0x000013d4    1 9            sym._fini
```

Let's check the main function - here we can see `entry0`, `entry1.init` and `entry2.fini`. Most of them are small, but we can see main function here:
```asm
[0x00001080]> pdf @0x00001165
            ;-- main:
/ (fcn) main 518
|   main ();
...many args...
|           0x00001165      55             push rbp
|           0x00001166      4889e5         mov rbp, rsp
|           0x00001169      4881eca00000.  sub rsp, 0xa0
|           0x00001170      89bd6cffffff   mov dword [local_94h], edi
|           0x00001176      4889b560ffff.  mov qword [local_a0h], rsi
|           0x0000117d      64488b042528.  mov rax, qword fs:[0x28]    ; [0x28:8]=0x3848 ; '('
|           0x00001186      488945f8       mov qword [local_8h], rax
|           0x0000118a      31c0           xor eax, eax
|           0x0000118c      83bd6cffffff.  cmp dword [local_94h], 1    ; [0x1:4]=0x2464c45
|       ,=< 0x00001193      7516           jne 0x11ab
|       |   0x00001195      488d3d680e00.  lea rdi, qword str.Usage:_._crackme_FLAG ; 0x2004 ; "Usage: ./crackme FLAG"
|       |   0x0000119c      e88ffeffff     call sym.imp.puts           ; int puts(const char *s)
|       |   0x000011a1      b801000000     mov eax, 1
|      ,==< 0x000011a6      e9aa010000     jmp 0x1355
```

This is what we are looking for. Now we can check the execution flow. First interesting part is strlen() call:
```asm
|      |`-> 0x000011ab      488b8560ffff.  mov rax, qword [local_a0h]
|      |    0x000011b2      4883c008       add rax, 8
|      |    0x000011b6      488b00         mov rax, qword [rax]
|      |    0x000011b9      4889c7         mov rdi, rax
|      |    0x000011bc      e87ffeffff     call sym.imp.strlen         ; size_t strlen(const char *s)
|      |    0x000011c1      4883f815       cmp rax, 0x15
|      |,=< 0x000011c5      7416           je 0x11dd
```
Looks like binary will compare input string length with 21(dec) if len() != 21 we will continue the execution here:
```asm
|      ||   0x000011c7      488d3d4c0e00.  lea rdi, qword str.Wrong_flag ; 0x201a ; "Wrong flag"
|      ||   0x000011ce      e85dfeffff     call sym.imp.puts           ; int puts(const char *s)
|      ||   0x000011d3      b801000000     mov eax, 1
|     ,===< 0x000011d8      e978010000     jmp 0x1355
```
it will print "Wrong Flag" and jump to next addr:
```asm
|  `--``--> 0x00001355      488b4df8       mov rcx, qword [local_8h]
|           0x00001359      64482b0c2528.  sub rcx, qword fs:[0x28]
|       ,=< 0x00001362      7405           je 0x1369
|       |   0x00001364      e8e7fcffff     call sym.imp.__stack_chk_fail ; void __stack_chk_fail(void)
|       |      ; JMP XREF from 0x00001362 (main)
|       `-> 0x00001369      c9             leave
\           0x0000136a      c3             ret
```
This will terminate the programm.

### Debugging
Let's return to good condition:
```asm
            0x000011dd      488d05410e00.  lea rax, qword str.sup3r_s3cr3t_k3y_1337 ; 0x2025 ; "sup3r_s3cr3t_k3y_1337"
|     ||    0x000011e4      48898578ffff.  mov qword [local_88h], rax
|     ||    0x000011eb      c78570ffffff.  mov dword [local_90h], 0
|     ||,=< 0x000011f5      eb2e           jmp 0x1225
```
If we put aaaaaa..(21 times) we will go to the right section:
```asm
|     ||`-> 0x55ec4d8081dd b    488d05410e00.  lea rax, qword str.sup3r_s3cr3t_k3y_1337 ; 0x55ec4d809025 ; "sup3r_s3cr3t_k3y_1337"
|     ||    0x55ec4d8081e4      48898578ffff.  mov qword [local_88h], rax
|     ||    0x55ec4d8081eb      c78570ffffff.  mov dword [local_90h], 0
|     ||,=< 0x55ec4d8081f5      eb2e           jmp 0x55ec4d808225
```
After that we can see wired section with some characters:
```asm
            0x564b5061022e b    c74580370000.  mov dword [local_80h], 0x37 ; '7' ; 55
|     ||    0x564b50610235      c745843f0000.  mov dword [local_7ch], 0x3f ; '?' ; 63
|     ||    0x564b5061023c      c745882f0000.  mov dword [local_78h], 0x2f ; '/' ; 47
|     ||    0x564b50610243      c7458c760000.  mov dword [local_74h], 0x76 ; 'v' ; 118
|     ||    0x564b5061024a      c745902b0000.  mov dword [local_70h], 0x2b ; '+' ; 43
|     ||    0x564b50610251      c74594620000.  mov dword [local_6ch], 0x62 ; 'b' ; 98
|     ||    0x564b50610258      c74598280000.  mov dword [local_68h], 0x28 ; '(' ; 40
|     ||    0x564b5061025f      c7459c210000.  mov dword [local_64h], 0x21 ; '!' ; 33
|     ||    0x564b50610266      c745a0340000.  mov dword [local_60h], 0x34 ; '4' ; 52
|     ||    0x564b5061026d      c745a40f0000.  mov dword [local_5ch], 0xf ; 15
|     ||    0x564b50610274      c745a8770000.  mov dword [local_58h], 0x77 ; 'w' ; 119
|     ||    0x564b5061027b      c745ac620000.  mov dword [local_54h], 0x62 ; 'b' ; 98
|     ||    0x564b50610282      c745b0480000.  mov dword [local_50h], 0x48 ; 'H' ; 72
|     ||    0x564b50610289      c745b4270000.  mov dword [local_4ch], 0x27 ; ''' ; 39
|     ||    0x564b50610290      c745b8750000.  mov dword [local_48h], 0x75 ; 'u' ; 117
|     ||    0x564b50610297      c745bc080000.  mov dword [local_44h], 8
|     ||    0x564b5061029e      c745c0560000.  mov dword [local_40h], 0x56 ; 'V' ; 86
|     ||    0x564b506102a5      c745c46a0000.  mov dword [local_3ch], 0x6a ; 'j' ; 106
|     ||    0x564b506102ac      c745c8680000.  mov dword [local_38h], 0x68 ; 'h' ; 104
|     ||    0x564b506102b3      c745cc4e0000.  mov dword [local_34h], 0x4e ; 'N' ; 78
|     ||    0x564b506102ba      c745d0680000.  mov dword [local_30h], 0x68 ; 'h' ; 104
```
This looks like a loop with characters checking and exit if they are not equals:
```asm
|    .----> 0x564b506102cd      488b8560ffff.  mov rax, qword [local_a0h]
|    :|||   0x564b506102d4      4883c008       add rax, 8
|    :|||   0x564b506102d8      488b10         mov rdx, qword [rax]
|    :|||   0x564b506102db      8b8574ffffff   mov eax, dword [local_8ch]
|    :|||   0x564b506102e1      4898           cdqe
|    :|||   0x564b506102e3      4801d0         add rax, rdx            ; '('
|    :|||   0x564b506102e6      0fb610         movzx edx, byte [rax]
|    :|||   0x564b506102e9      8b8574ffffff   mov eax, dword [local_8ch]
|    :|||   0x564b506102ef      4898           cdqe
|    :|||   0x564b506102f1      0fb64405e0     movzx eax, byte [rbp + rax - 0x20]
|    :|||   0x564b506102f6      31d0           xor eax, edx
|    :|||   0x564b506102f8      0fbed0         movsx edx, al
|    :|||   0x564b506102fb      8b8574ffffff   mov eax, dword [local_8ch]
|    :|||   0x564b50610301      4898           cdqe
|    :|||   0x564b50610303      8b448580       mov eax, dword [rbp + rax*4 - 0x80]
|    :|||   0x564b50610307      39c2           cmp edx, eax
|   ,=====< 0x564b50610309      7413           je 0x564b5061031e
|   |:|||   0x564b5061030b      488d3d080d00.  lea rdi, qword str.Wrong_flag ; 0x564b5061101a ; "Wrong flag"
|   |:|||   0x564b50610312      e819fdffff     call sym.imp.puts       ; int puts(const char *s)
|   |:|||   0x564b50610317      b801000000     mov eax, 1
|  ,======< 0x564b5061031c      eb37           jmp 0x564b50610355
|  |`-----> 0x564b5061031e      838574ffffff.  add dword [local_8ch], 1
|  | :|||      ; JMP XREF from 0x564b506102cb (main)
|  | :||`-> 0x564b50610325      83bd74ffffff.  cmp dword [local_8ch], 0x14 ; rax ; [0x14:4]=-1
|  | `====< 0x564b5061032c      7e9f           jle 0x564b506102cd
```
Key point is `    :|||   0x564b50610307      39c2           cmp edx, eax `

Providing string aaaaaa.... to the input we can see following compare:
```
[0x561751f9a307]> dr
rax = 0x00000037
rbx = 0x00000000
rcx = 0x0000001a
rdx = 0x00000030
```

### Understanding
First loop analysis:
```asm
.----> 0x564123eb71f7 b    8b8570ffffff   mov eax, dword [local_90h]
|    :|||   0x564123eb71fd      4863d0         movsxd rdx, eax
|    :|||   0x564123eb7200      488b8578ffff.  mov rax, qword [local_88h]
|    :|||   0x564123eb7207      4801d0         add rax, rdx            ; '('
|    :|||   0x564123eb720a      0fb600         movzx eax, byte [rax]
|    :|||   0x564123eb720d      83e822         sub eax, 0x22           ; '"'
|    :|||   0x564123eb7210      89c2           mov edx, eax
|    :|||   0x564123eb7212      8b8570ffffff   mov eax, dword [local_90h]
|    :|||   0x564123eb7218      4898           cdqe
|    :|||   0x564123eb721a      885405e0       mov byte [rbp + rax - 0x20], dl
|    :|||   0x564123eb721e      838570ffffff.  add dword [local_90h], 1
|    :|||      ; JMP XREF from 0x564123eb71f5 (main)
|    :||`-> 0x564123eb7225      83bd70ffffff.  cmp dword [local_90h], 0x14 ; [0x14:4]=-1 ; 20
```
We can translate it to pseudo-python code for better understanding:
```python
for c in "sup3r_s3cr3t_k3y_1337":
    result.append(ord(c) - 0x22)
```
In this case out shifted key will be:
```
['Q', 'S', 'N', '\x11', 'P', '=', 'Q', '\x11', 'A', 'P', '\x11', 'R', '=', 'I', '\x11', 'W', '=', '\x0f', '\x11', '\x11', '\x15']
```

Second Loop analysis:
```asm
            0x564123eb72cd b    488b8560ffff.  mov rax, qword [local_a0h]
|    :|||   0x564123eb72d4      4883c008       add rax, 8
|    :|||   0x564123eb72d8      488b10         mov rdx, qword [rax]
|    :|||   0x564123eb72db      8b8574ffffff   mov eax, dword [local_8ch]
|    :|||   0x564123eb72e1      4898           cdqe
|    :|||   0x564123eb72e3      4801d0         add rax, rdx            ; '('
|    :|||   0x564123eb72e6      0fb610         movzx edx, byte [rax]
|    :|||   0x564123eb72e9      8b8574ffffff   mov eax, dword [local_8ch]
|    :|||   0x564123eb72ef      4898           cdqe
|    :|||   ;-- rip:
|    :|||   0x564123eb72f1      0fb64405e0     movzx eax, byte [rbp + rax - 0x20]
|    :|||   0x564123eb72f6      31d0           xor eax, edx
|    :|||   0x564123eb72f8      0fbed0         movsx edx, al
|    :|||   0x564123eb72fb      8b8574ffffff   mov eax, dword [local_8ch]
|    :|||   0x564123eb7301      4898           cdqe
|    :|||   0x564123eb7303      8b448580       mov eax, dword [rbp + rax*4 - 0x80]
|    :|||   0x564123eb7307      39c2           cmp edx, eax
|   ,=====< 0x564123eb7309      7413           je 0x564123eb731e
```

We can reconstruct the logic with pseudo-python code:
```
for i in len(str):
    a = my_input[i]
    b = shifted_secret_key[i]
    calculation = b ^ a
    correct = <get from [rbp + rax - 0x20]>
    if calculation != correct:
       error...
```

### Debugging (second take)
Let's check cmp instruction according to our python-pseudocode for first and second chars.
```
b = 'Q'
a = ?
correct = 0x37 (according to register value)
```
After some calculations we can understand that:
* First xor is 0x37 for Q
* First char is 'f'!

Repeat same process on next iteration:
* Second xor is 0x3f for S
* Second char us 'l'

If we compare wired numbers from 0x564b50610235  with valid xors we will get 0x37 - '7', 0x3f - '?'. So each number is in "wired table", here is the XORs list:
```
[0x37, 0x3f, 0x2f, 0x76, 0x2b, 0x62, 0x28, 0x21, 0x34, 0xf, 0x77, 0x62, 0x48, 0x27, 0x75, 8, 0x56, 0x6a, 0x68, 0x4e, 0x68]
```
Conclusion: we can get full key using "wired numbers".

### Results
We can write simple function to calculate full secret key:
```python
s = "sup3r_s3cr3t_k3y_1337"
shifted_chars = [ord(x) - int('0x22', 16) for x in s]
correct_xors = [0x37, 0x3f, 0x2f, 0x76, 0x2b, 0x62, 0x28, 0x21, 0x34, 0xf, 0x77, 0x62, 0x48, 0x27, 0x75, 8, 0x56, 0x6a, 0x68, 0x4e, 0x68]

result = []
for i, key in enumerate(shifted_chars):
    for x in range(1, 255):
        if key ^ x == correct_xors[i]:
            result.append(x)
>>>''.join([chr(x) for x in result])
'flag{_y0u_f0und_key_}'
```
Here it is!
```bash
#./crackme 'flag{_y0u_f0und_key_}'
You found a flag! flag{_y0u_f0und_key_}
```